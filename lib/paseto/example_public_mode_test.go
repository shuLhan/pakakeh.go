// Copyright 2020, Shulhan <ms@kilabit.info>. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package paseto

import (
	"crypto/ed25519"
	"encoding/hex"
	"fmt"
	"log"
)

func ExamplePublicMode() {
	subjectMessage := "message"

	senderSK, _ := hex.DecodeString("e9ae9c7eae2fce6fd6727b5ca8df0fbc0aa60a5ffb354d4fdee1729e4e1463688d2160a4dc71a9a697d6ad6424da3f9dd18a259cdd51b0ae2b521e998b82d36e")
	senderPK, _ := hex.DecodeString("8d2160a4dc71a9a697d6ad6424da3f9dd18a259cdd51b0ae2b521e998b82d36e")
	senderKey := Key{
		ID:      "sender",
		Private: ed25519.PrivateKey(senderSK),
		Public:  ed25519.PublicKey(senderPK),
		AllowedSubjects: map[string]struct{}{
			subjectMessage: struct{}{},
		},
	}

	receiverSK, _ := hex.DecodeString("4983da648bff1fd3e1892df9c56370215aa640829a5cab02d6616b115fa0bc5707c22e74ab9b181f8d87bdf03cf88476ec4c35e5517e173f236592f6695d59f5")
	receiverPK, _ := hex.DecodeString("07c22e74ab9b181f8d87bdf03cf88476ec4c35e5517e173f236592f6695d59f5")
	receiverKey := Key{
		ID:      "receiver",
		Private: ed25519.PrivateKey(receiverSK),
		Public:  ed25519.PublicKey(receiverPK),
	}

	//
	// In the sender part, we register the sender key and the public key
	// of receiver in the list of peers.
	//
	sender := NewPublicMode(senderKey)
	sender.AddPeer(receiverKey)

	footer := map[string]interface{}{
		"FOOTER": "HERE",
	}
	token, err := sender.Pack(receiverKey.ID, subjectMessage, []byte("hello receiver"), footer)
	if err != nil {
		log.Fatal(err)
	}
	invalidToken, err := sender.Pack(receiverKey.ID, "unknown-subject", []byte("hello receiver"), footer)
	if err != nil {
		log.Fatal(err)
	}

	// token generated by sender and send to receiver
	// ...

	//
	// In the receiver part, we register the receiver key and the public key
	// of sender in the list of peers.
	//
	receiver := NewPublicMode(receiverKey)
	receiver.AddPeer(senderKey)

	// receiver receive the token from sender and unpack it ...
	gotData, gotFooter, err := receiver.Unpack(token)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Received data: %s\n", gotData)
	fmt.Printf("Received footer: %+v\n", gotFooter)

	// receiver receive invalid token from sender and unpack it ...
	gotData, gotFooter, err = receiver.Unpack(invalidToken)
	if err != nil {
		fmt.Println(err)
	}

	// Output:
	// Received data: hello receiver
	// Received footer: map[FOOTER:HERE]
	// token subject "unknown-subject" is not allowed for key "sender"
}
