// SPDX-FileCopyrightText: 2020 M. Shulhan <ms@kilabit.info>
//
// SPDX-License-Identifier: BSD-3-Clause

package paseto

import (
	"crypto/ed25519"
	"encoding/hex"
	"fmt"
	"log"
)

func ExamplePublicMode() {
	subjectMessage := "message"

	senderSK, _ := hex.DecodeString("e9ae9c7eae2fce6fd6727b5ca8df0fbc0aa60a5ffb354d4fdee1729e4e1463688d2160a4dc71a9a697d6ad6424da3f9dd18a259cdd51b0ae2b521e998b82d36e")
	senderPK, _ := hex.DecodeString("8d2160a4dc71a9a697d6ad6424da3f9dd18a259cdd51b0ae2b521e998b82d36e")
	senderKey := Key{
		ID:      "sender",
		Private: ed25519.PrivateKey(senderSK),
		Public:  ed25519.PublicKey(senderPK),
		AllowedSubjects: map[string]struct{}{
			subjectMessage: struct{}{},
		},
	}

	receiverSK, _ := hex.DecodeString("4983da648bff1fd3e1892df9c56370215aa640829a5cab02d6616b115fa0bc5707c22e74ab9b181f8d87bdf03cf88476ec4c35e5517e173f236592f6695d59f5")
	receiverPK, _ := hex.DecodeString("07c22e74ab9b181f8d87bdf03cf88476ec4c35e5517e173f236592f6695d59f5")
	receiverKey := Key{
		ID:      "receiver",
		Private: ed25519.PrivateKey(receiverSK),
		Public:  ed25519.PublicKey(receiverPK),
	}

	//
	// In the sender part, we register the sender key and the public key
	// of receiver in the list of peers.
	//
	sender, err := NewPublicMode(senderKey)
	if err != nil {
		log.Fatal(err)
	}

	err = sender.AddPeer(receiverKey)
	if err != nil {
		log.Fatal(err)
	}

	footer := map[string]any{
		"FOOTER": "HERE",
	}
	token, err := sender.Pack(receiverKey.ID, subjectMessage, []byte("hello receiver"), footer)
	if err != nil {
		log.Fatal(err)
	}
	invalidToken, err := sender.Pack(receiverKey.ID, "unknown-subject", []byte("hello receiver"), footer)
	if err != nil {
		log.Fatal(err)
	}

	// token generated by sender and send to receiver
	// ...

	//
	// In the receiver part, we register the receiver key and the public key
	// of sender in the list of peers.
	//
	receiver, err := NewPublicMode(receiverKey)
	if err != nil {
		log.Fatal(err)
	}

	err = receiver.AddPeer(senderKey)
	if err != nil {
		log.Fatal(err)
	}

	// receiver receive the token from sender and unpack it ...
	got, err := receiver.Unpack(token)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Received data: %s\n", got.Data)
	fmt.Printf("Received footer: %+v\n", got.Footer)

	// receiver receive invalid token from sender and unpack it ...
	got, err = receiver.Unpack(invalidToken)
	if err != nil {
		fmt.Println(err)
	}

	// Output:
	// Received data: hello receiver
	// Received footer: {Data:map[FOOTER:HERE] KID:sender}
	// token subject "unknown-subject" is not allowed for key "sender"
}
