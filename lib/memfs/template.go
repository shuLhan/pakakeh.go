// Copyright 2019, Shulhan <ms@kilabit.info>. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package memfs

import (
	"fmt"
	"text/template"
)

const (
	templateNameHeader       = "HEADER"
	templateNameGenerateNode = "GENERATE_NODE"
	templateNamePathFuncs    = "PATH_FUNCS"
)

// generateTemplate generate the .go source template.
//
// The .go source template contains three sections: HEADER, GENERATE_NODE,
// and PATH_FUNCS.
//
// The HEADER section accept single parameter: the package name, as a string.
//
// The GENERATE_NODE section accept single parameter: the *Node, which then
// converted into function that return the *Node itself,
//
//	function generate{{ Node.Path}} (node *memfs.Node) {
//		node = &memfs.Node{
//			...
//		}
//	}
//
// Then Node itself then registered in memfs global variable
// "GeneratedPathNode".
//
// The PATH_FUNCS section generate the init() function that map each
// Node's Path with the function generated from GENERATE_NODE.
func generateTemplate() (tmpl *template.Template, err error) {
	var textTemplate = `{{ define "HEADER" -}}
{{- .CommentHeader -}}
// Code generated by github.com/shuLhan/share/lib/memfs DO NOT EDIT.

package {{.PackageName}}

import (
	"github.com/shuLhan/share/lib/memfs"
)
{{end}}
{{define "GENERATE_NODE"}}
	{{- $varname := .Opts.Embed.VarName}}
func {{ .Node.GenFuncName}}() *memfs.Node {
	node := &memfs.Node{
		SysPath:         "{{.Node.SysPath}}",
		Path:            "{{.Node.Path}}",
		ContentType:     "{{.Node.ContentType}}",
		GenFuncName:     "{{.Node.GenFuncName}}",
{{- if .Node.Content }}
		Content:         []byte("{{range $x, $c := .Node.Content}}{{ printf "\\x%02X" $c }}{{end}}"),
{{- end }}
	}
	node.SetMode({{printf "%d" .Node.Mode}})
{{- if not .Opts.Embed.WithoutModTime }}
	node.SetModTimeUnix({{.Node.ModTime.Unix}}, {{.Node.ModTime.Nanosecond}})
{{- end }}
	node.SetName("{{.Node.Name}}")
	node.SetSize({{.Node.Size}})
	{{- range $x, $child := .Node.Childs}}
		{{- if $child.GenFuncName}}
	node.AddChild(_{{$varname}}_getNode({{$varname}}, "{{.Path}}", {{$child.GenFuncName}}))
		{{- end}}
	{{- end}}
	return node
}
{{end}}
{{define "PATH_FUNCS"}}
	{{- $varname := .Opts.Embed.VarName }}
// _{{ $varname}}_getNode is internal function to minimize duplicate node
// created on Node.AddChild() and on generatedPathNode.Set().
func _{{$varname}}_getNode(mfs *memfs.MemFS, path string, fn func() *memfs.Node) (node *memfs.Node) {
	node = mfs.PathNodes.Get(path)
	if node != nil {
		return node
	}
	return fn()
}

func init() {
	{{$varname}} = &memfs.MemFS{
		PathNodes: memfs.NewPathNode(),
		Opts: &memfs.Options{
			Root: "{{.Opts.Root}}",
			MaxFileSize: {{.Opts.MaxFileSize}},
			Includes: []string{
			{{- range $v := .Opts.Includes}}
				` + "`{{$v}}`" + `,
			{{- end}}
			},
			Excludes: []string{
			{{- range $v := .Opts.Excludes}}
				` + "`{{$v}}`" + `,
			{{- end}}
			},
			Embed: memfs.EmbedOptions{
				CommentHeader:  ` + "`" + `{{.Opts.Embed.CommentHeader}}` + "`" + `,
				PackageName:    "{{.Opts.Embed.PackageName}}",
				VarName:        "{{.Opts.Embed.VarName}}",
				GoFileName:     "{{.Opts.Embed.GoFileName}}",
				WithoutModTime: {{.Opts.Embed.WithoutModTime}},
			},
		},
	}

{{- range $x, $path := .PathNode.Paths }}
	{{- $node := $.PathNode.Get $path }}
	{{- if $node.GenFuncName}}
	{{$varname}}.PathNodes.Set("{{$path}}",
		_{{$varname}}_getNode({{$varname}}, "{{$path}}", {{ $node.GenFuncName }}))
	{{- end}}
{{- end}}

	{{$varname}}.Root = {{$varname}}.PathNodes.Get("/")
}
{{end}}
`
	tmpl, err = template.New("memfs").Parse(textTemplate)
	if err != nil {
		return nil, fmt.Errorf("generateTemplate: %w", err)
	}

	return tmpl, nil
}
